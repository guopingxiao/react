## React 入门初体验

react是有Facebook维护的一套框架，并在instagram社交中使用。它只是我么通常mvc,框架中v层，所以学起来简单，一共核心的方法就三个（createElement，createClass, reder）.

react是创建一个虚拟的dom(virtual dom)，这个dom不是真实的dom对象（实际上是一个js对象），用js对象将来存储一些dom上的信息，因此比真实的dom小得多，因为它只会记录一些必要的信息。

**创建一个虚拟dom的性能要远小于一个真实的dom。**

在前端开发一个web app时，现在流行做成单页面的形式，因此每一次的做一些交互时，都会涉及到dom的操作，因此这么无节制的操作dom的代价很大，如果我们只操作一些虚拟的dom,这会很好的降低对性能的消耗。在有必要的时候，将这些**需要改变的视图**渲染到页面中（reconciliation），去优化这些性能问题。新增一个元素的开销一般要大于修改一个元素的开销。修改需要改变的，重新渲染。

![](http://i.imgur.com/8TjRInZ.png)

react在优化上主要做了两点优化

- 一是在渲染方面，主要是虚拟dom
- 二是因为使用了虚拟dom,这使得app不需要依赖于某些端，可以一处开发，处处适用。二、为什么Web app有性能瓶颈？

### React 与WebApp
Web app输给Native app的地方，不是界面（UI），而是操作性能。主要是互动（interaction）和动画（animation）这两方面，会出现卡顿（jank），用户会感觉到明显的时滞，有时简直慢得难以忍受。

Web app的性能瓶颈，主要有以下原因。

（1）Web基于DOM，而DOM很慢。浏览器打开网页时，需要解析文档，在内存中生成DOM结构，如果遇到复杂的文档，这个过程是很慢的。可以想象一下，如果网页上有上万个、甚至几十万个形状（不管是图片或CSS），生成DOM需要多久？更不要提与其中某一个形状互动了。

（2）DOM拖慢JavaScript。所有的DOM操作都是同步的，会堵塞浏览器。JavaScript操作DOM时，必须等前一个操作结束，才能执行后一个操作。只要一个操作有卡顿，整个网页就会短暂失去响应。浏览器重绘网页的频率是60FPS（即16毫秒/帧），JavaScript做不到在16毫秒内完成DOM操作，因此产生了跳帧。用户体验上的不流畅、不连贯就源于此。

（3）网页是单线程的。现在的浏览器对于每个网页，只用一个线程处理。所有工作都在这一个线程上完成，包括布局、渲染、JavaScript执行、图像解码等等，怎么可能不慢？

（4）网页没有硬件加速。网页都是由CPU处理的，没用GPU进行图形加速。
上面这些原因，对于PC还不至于造成严重的性能问题，但是手机的硬件资源相对有限，用户互动又相对频繁，结果跟Native app一比，就完全落在了下风。



**创建一个ul**

createElment(para1， para2，para3)


- para1创建一个虚拟dom名称，任意元素的名称，如p,h1,div,组件名称；
- para2表示这个虚拟上一些必要的属性，className,title,id;
- para3是该所有元素上的所有子元素，如果是文本节点，可以直接写。

ReactDOM中的reder（）方法；接收三个参数，第一个是虚拟dom，第二个是真实dom,第三个是一个回调函数（不常用）；



**组件：**

如果一个虚拟dom复用多次，通常，我们将它封装在一个组件中，组件是一组虚拟dom树，

创建组件的方法是createClass，它的参数是一个对象，对象中的属性和方法是对组件的说明，有一个**render的方法**，它是将组件中的虚拟dom进行输出，所以可以将虚拟dom定义在render方法中；

render 返回值是一个函数，渲染到页面中要转化为虚拟dom树，用createElement方法；作用域是组件当前对象，可以访问组件中定义的方法与属性；组件第一个字母通常大写；

**jsx**

发现创建一个组件，真实烦人，创建一个虚拟dom成本过大，要写这么多，一个简单的li元素<li>男装/女装/服饰</li>要用这么多一行代码来实现，太不人性化了。

jsx语法就是让我们在html中的语法是一样的，但是页面不支持这种语法；所以我们要通过工程化工具编译，或者用babel2插件解析；

对于React的jsx语法，为了语义化文件，通常将文件定义为.jsx文件；

**插值**

在react中，插值语法是{}，在大括号中，可以书写任意的表达式，js内置的方法，自定义的方法，运算符，语句，注释也要写在插值符号中{}；className

**列表渲染**

先定义jsx的组件；然后渲染；


**组件的属性props获得属性的数据:**

定义个性化组件，可以给组件添加属性，同时，在组件里通过**this.props**来获得传递的数据；
但是有时候对于没有属性数据的props，为了传递数据的安全性，应该使用getDefaultProps来预先给定默认数据，此时的this指向是虚拟dom对象，而不是组件。


**样式定义**

样式的定义只能是对象，不能是字符串。
font-size这样的属性值要驼峰式书写
有前缀的css3属性-webkit第一个字母要大写

无论是在组价中还是虚拟dom中，style都应定义为对象字面量的形式，对象字面量里值可以是表达式。

**组件状态**

state:如果组件在创建并渲染后，不会再改变，也就说与用户不产生交互，或者发送异步请求；这类组件我们只需在创建的时候为其添加一些属性即可控制其行为，我们称这类组件为无状态组件（stateless）

如果组件在创建后会根据用户的不同交互而发生不同的行为（样式）变化，这类组件我们称之为有状态组件。

组件内一般会维护一个状态，这个变量就是state,和props一样，我们可以更改其数据；但是props是在组件的创建时传递的不同数据决定，因此一般是改变不了的（除了子组件外）

而state通常是随着交互的改变而改变，因此伴随着一个交互。

**每次props和state的改变都会执行一次render方法重新渲染组件，组件是否更改是由虚拟dom是否改变决定。**

state也可以设置初始状态，设置方法和props一样，用getInitialState方法来设定默认值，通过return{}来设置；在组件内部通过this.state来获得数据。

在组件内改变状态通过setState方法来改变，setState方法调用一般会触发render方法，交互就会有事件触发，react定义事件与html中定义事件的方式是一样的，通过on+事件名称组成。

事件都有回调函数，通常将事件定义在组件内部，通过this来添加事件的回调函数。

回调函数的作用域是实例化的组件内；
第一个参数是事件对象event;


参考： [http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html](http://www.ruanyifeng.com/blog/2015/02/future-of-dom.html)
margin-right:-10px ; 像这种负margin值的布局很有用哦；






